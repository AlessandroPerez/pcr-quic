rd_("AjContains the success valueCkChain key: TK^{(e,pn)}_{dir}, updated after each derivationAhContains the error valueBdHighest packet number derived so farBoCreate a new AES-GCM context with the given keyBmCreate a new SecretBytes with zeroed contentsBiCreate a new PcrPacketKey from epoch keysBoCreate a new PCR crypto context after handshakeCgCreate a new PCR transport parameter with custom valuesAlCreate a new PCR_REKEY frameB`Create a new PCR_REKEY_ACK frameAnDone processing (not an error)CmLow-level FFI bindings to BoringSSL via the C crypto shim \xe2\x80\xa6AoReturns the argument unchanged.000000000000BaCalls <code>U::from(self)</code>.000000000000AkPCR-QUIC Epoch Key ScheduleBlDecrypt with cached key schedule (fast path)BlEncrypt with cached key schedule (fast path)BkEpoch identifier (monotonically increasing)AiKEM algorithm identifiersAjGeneric error with messageCnCache of nonce keys for skipped packets: pn \xe2\x86\x92 NK^{(e,pn)}\xe2\x80\xa6BeThe epoch number these keys belong toAeGet the current epochAdCurrent epoch numberlEpoch numberAjPCR-QUIC Frame DefinitionsBcResult type for PCR-QUIC operationsBgX25519 only (fallback, no post-quantum)BiDecode the transport parameter from bytesBgEncode the transport parameter to bytesBaAES-256 key for receiving packetsAoAES-256 key for sending packetsA`KEM algorithm IDAdAgreed KEM algorithmAiGet negotiated parametersAlPCR-QUIC Transport ParameterCeSHA-256 direct hash (faster than HKDF for ratchet \xe2\x80\xa6CaMaximum out-of-order window for packet decryptionBdAgreed window size (minimum of both)AgPCR-QUIC Crypto ContextA`Encrypt a packetCmIV base for this epoch: IV^{(e)}_{dir} (full 32 bytes per \xe2\x80\xa6CnIV base for receiving (used with per-packet nonce ratchet) \xe2\x80\xa6ClIV base for sending (used with per-packet nonce ratchet) \xe2\x80\xa6BePCR-QUIC Per-Packet Symmetric RatchetA`Protocol versionAdPCR-QUIC error typesBiAES-256 key for this epoch: K^{(e)}_{dir}BfGet a reference to the underlying datalNew epoch IDAeAcknowledged epoch IDAeParse KEM ID from u16AnReturns the opposite directionBjPCR-QUIC: Double Ratchet Protocol for QUICBhPCR-QUIC Crypto Shim - Rust FFI bindingsBcWhether this epoch is being retiredAnGet send key for current epochAiEncode the frame to bytes0BgCalculate the wire length of this frame0AhDirection of packet flowAoKeys derived for a single epochAdKEM operation failedBkNegotiate parameters between local and peerChPRK for chain/IV derivation (used by per-packet ratchet)CjPRK for epoch key derivation (kept for potential rekeying)AeAEAD operation failedAdEpoch state trackingAeHKDF operation failedBiCreate SecretBytes from an existing arrayCiDecode a frame from bytes (assumes frame type already \xe2\x80\xa60BgGet the highest packet number processedB`Get the 12-byte IV for receivingAnGet the 12-byte IV for sendingBhGet next epoch number (if in transition)BfSHA-256 direct hash (faster than HKDF)CbSHA-256 of two concatenated inputs (no allocation)BaCurrent PCR-QUIC protocol versionCnA wrapper that securely zeros memory on drop. Use this for \xe2\x80\xa6CdClear all cached skipped keys (for security cleanup)CcDerive PRK_epoch and PRK_chain from a shared secretBmHKDF-SHA256 key derivation (Extract + Expand)BmOpen (decrypt) a packet using the PCR ratchetBmSeal (encrypt) a packet using the PCR ratchetAdSecurely zero memoryBdTry to decrypt with available epochsCgAES-256-GCM encryption context with cached key scheduleAnCryptographic operation failedAdInvalid frame formatAhInvalid state transitionCaPCR Packet Key state for one direction of trafficAmWhen this epoch was activatedBnGet a mutable reference to the underlying dataBkPacket count on this epoch (for retirement)BnGenerate cryptographically secure random bytesAeRetire old epoch keysAeCheck if rekey is dueoEpoch not foundBbPCR_REKEY frame for epoch rekeyingBdCompute the final nonce for a packetAhGet current epoch numberChCheck if two transport parameters are compatible for \xe2\x80\xa6CiRemove a specific packet\xe2\x80\x99s cached key (e.g., after ACK)ChEncrypt in-place with cached key schedule (fastest path)BdX25519 ECDH shared secret derivationAnBuffer too small for operationAhClient sending to serverCnPCR-QUIC transport parameter ID (private-use range: 0x41 + \xe2\x80\xa6AhServer sending to clientAjX25519 + ML-KEM-768 hybridBdAES-256-GCM authenticated decryptionBdAES-256-GCM authenticated encryptionBbGet ciphertext length for this KEMAnInitiate a rekey (sender side)BkKEM ciphertext (encapsulated shared secret)BhGet our KEM public key (to send to peer)BbSHA-256 of two concatenated inputsBbGet public key length for this KEMBbGet secret key length for this KEMAiX25519 keypair generationClCommit the chain key update after encrypting all packets \xe2\x80\xa6AnHKDF-SHA256 (Extract + Expand)AdSecurely zero memoryBiPacket decryption failed (authentication)CgPCR Crypto Context for managing epoch keys and rekeyingCgPCR_REKEY_ACK frame for acknowledging epoch transitionsCcHKDF-SHA256 into a fixed-size array (no allocation)CkInitialize the info prefix for a specific direction and CIDBnGenerate cryptographically secure random bytesBoValidate ciphertext length against expected KEMBePCR-QUIC transport parameter contentsBjDerive all epoch keys from a shared secretCaCreate from SecretBytes (convenience constructor)AhHybrid KEM decapsulationAhHybrid KEM encapsulationBdX25519 ECDH shared secret derivationCfFill buffer with cryptographically secure random bytesBkTLS exporter label for initial epoch secretAmHKDF-SHA256 Expand phase onlyCcHybrid KEM (X25519 + ML-KEM-768) keypair generationC`Get nonce for an incoming packet (receiver path)BkAES-256-GCM authenticated decryption (open)BkAES-256-GCM authenticated encryption (seal)AiX25519 keypair generationBoGet receive key, trying current then next epochBaGet send key for a specific epochBnDefault window size for skipped packet cachingAeInvalid packet numberBiNegotiated PCR parameters after handshakeBlActivate the next epoch (switch to new keys)CmDerive the nonce key for a specific packet number (sender \xe2\x80\xa6AnHKDF-SHA256 Extract phase onlyC`Process received PCR_REKEY frame (receiver side)CdRekey interval in seconds (default: 120 = 2 minutes)BgAgreed rekey interval (minimum of both)CeSeal (encrypt) a packet with a pre-computed nonce keyBcCheck if an epoch should be retiredBhPCR_REKEY frame type (private-use range)CdMaximum number of concurrent epochs (current + next)CeMaximum packets on old epoch before forced retirementBoDerive epoch keys for a specific direction onlyCcCreate new AES-GCM context with cached key scheduleAhHybrid KEM decapsulationAhHybrid KEM encapsulationClMaximum time to keep old epoch keys (fallback if PTO not \xe2\x80\xa6AdFree AES-GCM contextBlAES-GCM open with cached context (fast path)BlAES-GCM seal with cached context (fast path)AmHKDF-SHA256 Expand phase onlyCcHybrid KEM (X25519 + ML-KEM-768) keypair generationCfAES-256-GCM authenticated encryption (in-place, no \xe2\x80\xa6CjHKDF-SHA256 Expand phase into fixed buffer (no allocation)BjHybrid KEM decapsulation with slice inputsBjHybrid KEM encapsulation with slice inputsAnHKDF-SHA256 Extract phase onlyC`Set peer\xe2\x80\x99s KEM public key (received from peer)AhPCR_REKEY_ACK frame typeCeDerive nonce key for a datagram (optimization for \xe2\x80\xa6CkAES-GCM in-place seal with separate tag output (fastest \xe2\x80\xa6")